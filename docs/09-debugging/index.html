<!doctype html><html lang=en dir=ltr><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Debugging #  Debugging WebRTC can be a daunting task. There are a lot of moving parts, and they all can break independently. If you aren&rsquo;t careful, you can lose weeks of time looking at the wrong things. When you do finally find the part that is broken, you will need to learn a bit to understand why.
This chapter will get you in the mindset to debug WebRTC. It will show you how to break down the problem."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Debugging"><meta property="og:description" content="Debugging #  Debugging WebRTC can be a daunting task. There are a lot of moving parts, and they all can break independently. If you aren&rsquo;t careful, you can lose weeks of time looking at the wrong things. When you do finally find the part that is broken, you will need to learn a bit to understand why.
This chapter will get you in the mindset to debug WebRTC. It will show you how to break down the problem."><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/docs/09-debugging/"><meta property="article:modified_time" content="2021-05-10T14:58:32+03:00"><meta property="og:site_name" content="WebRTC for the Curious"><title>Debugging | WebRTC for the Curious</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/09-debugging/ title=デバッグ><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/09-debugging/ title=调试><link rel=stylesheet href=/book.min.6c7c6446dfdee7c8c933e9bbc6e80ee3ed6c913b2a59519f2092c3c6a9d63e55.css integrity="sha256-bHxkRt/e58jJM+m7xugO4+1skTsqWVGfIJLDxqnWPlU="><script defer src=/en.search.min.093d9506c880a98ea3eefb71ca2a7522c9fd7ce04fb7b9349637f5b28907c203.js integrity="sha256-CT2VBsiAqY6j7vtxyip1Isn9fOBPt7k0ljf1sokHwgM="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><span>WebRTC for the Curious</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://webrtcforthecurious.com/docs/01-what-why-and-how/>What, Why and How</a></li><li><a href=https://webrtcforthecurious.com/docs/02-signaling/>Signaling</a></li><li><a href=https://webrtcforthecurious.com/docs/03-connecting/>Connecting</a></li><li><a href=https://webrtcforthecurious.com/docs/04-securing/>Securing</a></li><li><a href=https://webrtcforthecurious.com/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=https://webrtcforthecurious.com/docs/06-media-communication/>Media Communication</a></li><li><a href=https://webrtcforthecurious.com/docs/07-data-communication/>Data Communication</a></li><li><a href=https://webrtcforthecurious.com/docs/08-applied-webrtc/>Applied WebRTC</a></li><li><a href=https://webrtcforthecurious.com/docs/09-debugging/ class=active>Debugging</a></li><li><a href=https://webrtcforthecurious.com/docs/10-history-of-webrtc/>History</a></li><li><a href=https://webrtcforthecurious.com/docs/11-faq/>FAQ</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Debugging</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#isolate-the-problem>Isolate The Problem</a></li><li><a href=#tools-of-the-trade>Tools of the trade</a></li></ul></li><li><a href=#latency>Latency</a><ul><li><a href=#manual-end-to-end-latency-measurement>Manual end-to-end latency measurement</a></li><li><a href=#automatic-end-to-end-latency-measurement>Automatic end-to-end latency measurement</a></li><li><a href=#latency-debugging-tips>Latency Debugging Tips</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=debugging>Debugging
<a class=anchor href=#debugging>#</a></h1><p>Debugging WebRTC can be a daunting task. There are a lot of moving parts, and they all can break independently. If you aren&rsquo;t careful, you can lose weeks of time looking at the wrong things. When you do finally find the part that is broken, you will need to learn a bit to understand why.</p><p>This chapter will get you in the mindset to debug WebRTC. It will show you how to break down the problem. After we know the problem, we will give a quick tour of the popular debugging tools.</p><h3 id=isolate-the-problem>Isolate The Problem
<a class=anchor href=#isolate-the-problem>#</a></h3><p>When debugging, you need to isolate where the issue is coming from. Start from the beginning of the&mldr;</p><h4 id=signaling-failure>Signaling Failure
<a class=anchor href=#signaling-failure>#</a></h4><h4 id=networking-failure>Networking Failure
<a class=anchor href=#networking-failure>#</a></h4><p>Test your STUN server using netcat:</p><ol><li><p>prepare the <strong>20-byte</strong> binding request packet:</p><pre><code>echo -ne &quot;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&quot; | hexdump -C
00000000  00 01 00 00 21 12 a4 42  54 45 53 54 54 45 53 54  |....!..BTESTTEST|
00000010  54 45 53 54                                       |TEST|
00000014
</code></pre><p>interpretation:</p><ul><li><p><code>00 01</code> is the message type</p></li><li><p><code>00 00</code> is the length of the data section</p></li><li><p><code>21 12 a4 42</code> is the magic cookie</p></li><li><p>and <code>54 45 53 54 54 45 53 54 54 45 53 54</code> (which decodes to ASCII <code>TESTTESTTEST</code>) is the 12-byte transaction ID</p></li></ul></li><li><p>send the request and wait for the <strong>32 byte</strong> response:</p><pre><code>stunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne &quot;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&quot; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C
00000000  01 01 00 0c 21 12 a4 42  54 45 53 54 54 45 53 54  |....!..BTESTTEST|
00000010  54 45 53 54 00 20 00 08  00 01 6f 32 7f 36 de 89  |TEST. ....o2.6..|
00000020
</code></pre><p>interpretation:</p><ul><li><p><code>01 01</code> is the message type</p></li><li><p><code>00 0c</code> is the length of the data section which decodes to 12 in decimal</p></li><li><p><code>21 12 a4 42</code> is the magic cookie</p></li><li><p>and <code>54 45 53 54 54 45 53 54 54 45 53 54</code> (which decodes to ASCII <code>TESTTESTTEST</code>) is the 12-byte transaction ID</p></li><li><p><code>00 20 00 08 00 01 6f 32 7f 36 de 89</code> is the 12-byte data, interpretation:</p><ul><li><p><code>00 20</code> is the type: <code>XOR-MAPPED-ADDRESS</code></p></li><li><p><code>00 08</code> is the length of the value section which decodes to 8 in decimal</p></li><li><p><code>00 01 6f 32 7f 36 de 89</code> is the data value, interpretation:</p><ul><li><p><code>00 01</code> is the address type (IPv4)</p></li><li><p><code>6f 32</code> is the XOR-mapped port</p></li><li><p><code>7f 36 de 89</code> is the XOR-mapped IP address</p></li></ul></li></ul></li></ul></li></ol><p>Decoding the XOR-mapped section is cumbersome, but we can trick the stun server to perform a dummy XOR-mapping, by supplying an (invalid) dummy magic cookie set to <code>00 00 00 00</code>:</p><pre><code>stunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne &quot;\x00\x01\x00\x00\x00\x00\x00\x00TESTTESTTEST&quot; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C
00000000  01 01 00 0c 00 00 00 00  54 45 53 54 54 45 53 54  |........TESTTEST|
00000010  54 45 53 54 00 01 00 08  00 01 4e 20 5e 24 7a cb  |TEST......N ^$z.|
00000020
</code></pre><p>XOR-ing against the dummy magic cookie is idempotent, so the port and address will be in clear in the response (this will not work in all situations, because some routers manipulate the passing packets, cheating on the IP address); if we look at the returned data value (last eight bytes):</p><ul><li><p><code>00 01 4e 20 5e 24 7a cb</code> is the data value, interpretation:</p><ul><li><p><code>00 01</code> is the address type (IPv4)</p></li><li><p><code>4e 20</code> is the mapped port, which decodes to 20000 in decimal</p></li><li><p><code>5e 24 7a cb</code> is the IP address, which decodes to <code>94.36.122.203</code> in dotted-decimal notation.</p></li></ul></li></ul><h4 id=security-failure>Security Failure
<a class=anchor href=#security-failure>#</a></h4><h4 id=media-failure>Media Failure
<a class=anchor href=#media-failure>#</a></h4><h4 id=data-failure>Data Failure
<a class=anchor href=#data-failure>#</a></h4><h3 id=tools-of-the-trade>Tools of the trade
<a class=anchor href=#tools-of-the-trade>#</a></h3><h4 id=netcat-nc>netcat (nc)
<a class=anchor href=#netcat-nc>#</a></h4><p><a href=https://en.wikipedia.org/wiki/Netcat>netcat</a> is command-line networking utility for reading from and writing to network connections using TCP or UDP. It is tipically available as the <code>nc</code> command.</p><h4 id=tcpdump>tcpdump
<a class=anchor href=#tcpdump>#</a></h4><p><a href=https://en.wikipedia.org/wiki/Tcpdump>tcpdump</a> is a command-line data-network packet analyzer.</p><p>Common commands:</p><ul><li><p>capture UDP packets to and from port 19302, print hexdump of the packet content:</p><p><code>sudo tcpdump 'udp port 19302' -xx</code></p></li><li><p>same but save packets in PCAP (packet capture) file for later inspection</p><p><code>sudo tcpdump 'udp port 19302' -w stun.pcap</code></p><p>the PCAP file can be opened with the wireshark GUI: <code>wireshark stun.pcap</code></p></li></ul><h4 id=wireshark>wireshark
<a class=anchor href=#wireshark>#</a></h4><h4 id=webrtc-internals>webrtc-internals
<a class=anchor href=#webrtc-internals>#</a></h4><p>Chrome comes with a built-in WebRTC statistics page available at <a href=chrome://webrtc-internals>chrome://webrtc-internals</a>.</p><h2 id=latency>Latency
<a class=anchor href=#latency>#</a></h2><p>How do you know you have high latency?</p><p>You may have noticed that your video is lagging, but do you know precisely how much it is lagging?
To be able to reduce this latency, you have to start by measuring it first.</p><p>True latency is supposed to be measured end-to-end.</p><p>That means not just the latency of the network path between the sender and the receiver, but the combined latency of camera capture, frame encoding, transmission, receiving, decoding and displaying, as well as possible queueing between any of these steps.</p><p>End-to-end latency is not a simple sum of latencies of each component.</p><p>While you could theoretically measure the latency of the components of a live video transmission pipeline separately and then add them together, in practice, at least some components will be either inaccessible for instrumentation, or produce significantly different results when measured outside of the pipeline.
Variable queue depths between pipeline stages, network topology and camera exposure changes are just a few examples of components affecting end-to-end latency.</p><p>The intrinsic latency of each component in your live streaming system can change and affect downstream components.
Even the content of captured video affects latency.
For example, many more bits are required for high frequency features such as tree branches, compared to a low frequency clear blue sky.
A camera with auto exposure turned on may take <em>much</em> longer than the expected 33 milliseconds to capture a frame, even if when the capture rate is set to 30 frames per second.
Transmission over the network, especially so cellular, is also very dynamic due to changing demand.
More users introduce more chatter on the air.
Your physical location (notorious low signal zones) and multiple other factors increase packet loss and latency.
What happens when you send a packet to a network interface, say wifi adapter or an LTE modem for delivery?
If it can not be immediately delivered it is queued on the interface, the larger the queue the more latency such network interface introduces.</p><h3 id=manual-end-to-end-latency-measurement>Manual end-to-end latency measurement
<a class=anchor href=#manual-end-to-end-latency-measurement>#</a></h3><p>When we talk about end-to-end latency, we mean the time between an event happening and it being observed - video frames appearing on the screen.</p><pre><code>EndToEndLatency = T(observe) - T(happen)
</code></pre><p>A naive approach is to record time at event happening and subtract it from the time at observation.
However as precision goes down to milliseconds time synchronization becomes an issue.
Trying to synchronize clocks across distributed systems is mostly futile, even a small error in time sync produces unreliable latency measurement.</p><p>A simple workaround for clock sync issues is to use the same clock.
Put sender and receiver in the same frame of reference.</p><p>Imagine you have a ticking millisecond clock or any other event source really.
You want to measure latency in a system that live streams the clock to a remote screen by pointing a camera at it.
An obvious way to measure time between the millisecond timer ticking (T<code>happen</code>) and video frames of the clock appear on screen (T<code>observe</code>) is the following:</p><ul><li>Point your camera at the millisecond clock.</li><li>Send video frames to a receiver that is in the same physical location.</li><li>Take a picture (use your phone) of the millisecond timer and the received video on screen.</li><li>Subtract two times.
That is the most true-to-yourself end-to-end latency measurement.
It accounts for all components latencies (camera, encoder, network, decoder) and does not rely on any clock synchronization.</li></ul><p><img src=../images/09-diy-latency.png alt="DIY Latency" title="DIY Latency Measurement">.
<img src=../images/09-diy-latency-happen-observe.png alt="DIY Latency Example" title="DIY Latency Measurement Example">
In the photo above measured end-to-end latency is 101 msec. Event happening right now is 10:16:02.862 but live streaming system observer sees 10:16:02.761.</p><h3 id=automatic-end-to-end-latency-measurement>Automatic end-to-end latency measurement
<a class=anchor href=#automatic-end-to-end-latency-measurement>#</a></h3><h4 id=example-latency-estimation>Example latency estimation
<a class=anchor href=#example-latency-estimation>#</a></h4><h4 id=actual-video-time-in-browser>Actual video time in browser
<a class=anchor href=#actual-video-time-in-browser>#</a></h4><h3 id=latency-debugging-tips>Latency Debugging Tips
<a class=anchor href=#latency-debugging-tips>#</a></h3><h4 id=camera-latency>Camera latency
<a class=anchor href=#camera-latency>#</a></h4><h4 id=encoder-latency>Encoder latency
<a class=anchor href=#encoder-latency>#</a></h4><h4 id=network-latency>Network latency
<a class=anchor href=#network-latency>#</a></h4><h4 id=receiver-side-latency>Receiver side latency
<a class=anchor href=#receiver-side-latency>#</a></h4></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</li></ul><ul class=book-languages-list><li class=active><a href=https://webrtcforthecurious.com/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/09-debugging/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Turkish</a></li><li><a href=https://webrtcforthecurious.com/fa/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Persian</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/09-debugging/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
日本語</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/09-debugging/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/8f7f100057d02557a1880fe2a3762396443a742b title="Last modified by Alex Zhukov | May 10, 2021" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>May 10, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/09-debugging.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#isolate-the-problem>Isolate The Problem</a></li><li><a href=#tools-of-the-trade>Tools of the trade</a></li></ul></li><li><a href=#latency>Latency</a><ul><li><a href=#manual-end-to-end-latency-measurement>Manual end-to-end latency measurement</a></li><li><a href=#automatic-end-to-end-latency-measurement>Automatic end-to-end latency measurement</a></li><li><a href=#latency-debugging-tips>Latency Debugging Tips</a></li></ul></li></ul></nav></div></aside></main></body></html>